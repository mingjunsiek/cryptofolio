// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'freezed_classes.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
Coin _$CoinFromJson(Map<String, dynamic> json) {
  return _Coin.fromJson(json);
}

class _$CoinTearOff {
  const _$CoinTearOff();

// ignore: unused_element
  _Coin call(
      String id,
      String symbol,
      String name,
      String image,
      double current_price,
      int market_cap,
      int market_cap_rank,
      @nullable double fully_diluted_valuation,
      double total_volume,
      @nullable double high_24h,
      @nullable double low_24h,
      @nullable double price_change_24h,
      @nullable double price_change_percentage_24h,
      @nullable double market_cap_change_24h,
      @nullable double market_cap_change_percentage_24h,
      @nullable double circulating_supply,
      @nullable double total_supply,
      @nullable double max_supply,
      @nullable double ath,
      @nullable double ath_change_percentage,
      @nullable String ath_date,
      @nullable double atl,
      @nullable double atl_change_percentage,
      @nullable String atl_date,
      @nullable Map<String, dynamic> roi,
      String last_updated) {
    return _Coin(
      id,
      symbol,
      name,
      image,
      current_price,
      market_cap,
      market_cap_rank,
      fully_diluted_valuation,
      total_volume,
      high_24h,
      low_24h,
      price_change_24h,
      price_change_percentage_24h,
      market_cap_change_24h,
      market_cap_change_percentage_24h,
      circulating_supply,
      total_supply,
      max_supply,
      ath,
      ath_change_percentage,
      ath_date,
      atl,
      atl_change_percentage,
      atl_date,
      roi,
      last_updated,
    );
  }
}

// ignore: unused_element
const $Coin = _$CoinTearOff();

mixin _$Coin {
  String get id;
  String get symbol;
  String get name;
  String get image;
  double get current_price;
  int get market_cap;
  int get market_cap_rank;
  @nullable
  double get fully_diluted_valuation;
  double get total_volume;
  @nullable
  double get high_24h;
  @nullable
  double get low_24h;
  @nullable
  double get price_change_24h;
  @nullable
  double get price_change_percentage_24h;
  @nullable
  double get market_cap_change_24h;
  @nullable
  double get market_cap_change_percentage_24h;
  @nullable
  double get circulating_supply;
  @nullable
  double get total_supply;
  @nullable
  double get max_supply;
  @nullable
  double get ath;
  @nullable
  double get ath_change_percentage;
  @nullable
  String get ath_date;
  @nullable
  double get atl;
  @nullable
  double get atl_change_percentage;
  @nullable
  String get atl_date;
  @nullable
  Map<String, dynamic> get roi;
  String get last_updated;

  Map<String, dynamic> toJson();
  $CoinCopyWith<Coin> get copyWith;
}

abstract class $CoinCopyWith<$Res> {
  factory $CoinCopyWith(Coin value, $Res Function(Coin) then) =
      _$CoinCopyWithImpl<$Res>;
  $Res call(
      {String id,
      String symbol,
      String name,
      String image,
      double current_price,
      int market_cap,
      int market_cap_rank,
      @nullable double fully_diluted_valuation,
      double total_volume,
      @nullable double high_24h,
      @nullable double low_24h,
      @nullable double price_change_24h,
      @nullable double price_change_percentage_24h,
      @nullable double market_cap_change_24h,
      @nullable double market_cap_change_percentage_24h,
      @nullable double circulating_supply,
      @nullable double total_supply,
      @nullable double max_supply,
      @nullable double ath,
      @nullable double ath_change_percentage,
      @nullable String ath_date,
      @nullable double atl,
      @nullable double atl_change_percentage,
      @nullable String atl_date,
      @nullable Map<String, dynamic> roi,
      String last_updated});
}

class _$CoinCopyWithImpl<$Res> implements $CoinCopyWith<$Res> {
  _$CoinCopyWithImpl(this._value, this._then);

  final Coin _value;
  // ignore: unused_field
  final $Res Function(Coin) _then;

  @override
  $Res call({
    Object id = freezed,
    Object symbol = freezed,
    Object name = freezed,
    Object image = freezed,
    Object current_price = freezed,
    Object market_cap = freezed,
    Object market_cap_rank = freezed,
    Object fully_diluted_valuation = freezed,
    Object total_volume = freezed,
    Object high_24h = freezed,
    Object low_24h = freezed,
    Object price_change_24h = freezed,
    Object price_change_percentage_24h = freezed,
    Object market_cap_change_24h = freezed,
    Object market_cap_change_percentage_24h = freezed,
    Object circulating_supply = freezed,
    Object total_supply = freezed,
    Object max_supply = freezed,
    Object ath = freezed,
    Object ath_change_percentage = freezed,
    Object ath_date = freezed,
    Object atl = freezed,
    Object atl_change_percentage = freezed,
    Object atl_date = freezed,
    Object roi = freezed,
    Object last_updated = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      symbol: symbol == freezed ? _value.symbol : symbol as String,
      name: name == freezed ? _value.name : name as String,
      image: image == freezed ? _value.image : image as String,
      current_price: current_price == freezed
          ? _value.current_price
          : current_price as double,
      market_cap: market_cap == freezed ? _value.market_cap : market_cap as int,
      market_cap_rank: market_cap_rank == freezed
          ? _value.market_cap_rank
          : market_cap_rank as int,
      fully_diluted_valuation: fully_diluted_valuation == freezed
          ? _value.fully_diluted_valuation
          : fully_diluted_valuation as double,
      total_volume: total_volume == freezed
          ? _value.total_volume
          : total_volume as double,
      high_24h: high_24h == freezed ? _value.high_24h : high_24h as double,
      low_24h: low_24h == freezed ? _value.low_24h : low_24h as double,
      price_change_24h: price_change_24h == freezed
          ? _value.price_change_24h
          : price_change_24h as double,
      price_change_percentage_24h: price_change_percentage_24h == freezed
          ? _value.price_change_percentage_24h
          : price_change_percentage_24h as double,
      market_cap_change_24h: market_cap_change_24h == freezed
          ? _value.market_cap_change_24h
          : market_cap_change_24h as double,
      market_cap_change_percentage_24h:
          market_cap_change_percentage_24h == freezed
              ? _value.market_cap_change_percentage_24h
              : market_cap_change_percentage_24h as double,
      circulating_supply: circulating_supply == freezed
          ? _value.circulating_supply
          : circulating_supply as double,
      total_supply: total_supply == freezed
          ? _value.total_supply
          : total_supply as double,
      max_supply:
          max_supply == freezed ? _value.max_supply : max_supply as double,
      ath: ath == freezed ? _value.ath : ath as double,
      ath_change_percentage: ath_change_percentage == freezed
          ? _value.ath_change_percentage
          : ath_change_percentage as double,
      ath_date: ath_date == freezed ? _value.ath_date : ath_date as String,
      atl: atl == freezed ? _value.atl : atl as double,
      atl_change_percentage: atl_change_percentage == freezed
          ? _value.atl_change_percentage
          : atl_change_percentage as double,
      atl_date: atl_date == freezed ? _value.atl_date : atl_date as String,
      roi: roi == freezed ? _value.roi : roi as Map<String, dynamic>,
      last_updated: last_updated == freezed
          ? _value.last_updated
          : last_updated as String,
    ));
  }
}

abstract class _$CoinCopyWith<$Res> implements $CoinCopyWith<$Res> {
  factory _$CoinCopyWith(_Coin value, $Res Function(_Coin) then) =
      __$CoinCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      String symbol,
      String name,
      String image,
      double current_price,
      int market_cap,
      int market_cap_rank,
      @nullable double fully_diluted_valuation,
      double total_volume,
      @nullable double high_24h,
      @nullable double low_24h,
      @nullable double price_change_24h,
      @nullable double price_change_percentage_24h,
      @nullable double market_cap_change_24h,
      @nullable double market_cap_change_percentage_24h,
      @nullable double circulating_supply,
      @nullable double total_supply,
      @nullable double max_supply,
      @nullable double ath,
      @nullable double ath_change_percentage,
      @nullable String ath_date,
      @nullable double atl,
      @nullable double atl_change_percentage,
      @nullable String atl_date,
      @nullable Map<String, dynamic> roi,
      String last_updated});
}

class __$CoinCopyWithImpl<$Res> extends _$CoinCopyWithImpl<$Res>
    implements _$CoinCopyWith<$Res> {
  __$CoinCopyWithImpl(_Coin _value, $Res Function(_Coin) _then)
      : super(_value, (v) => _then(v as _Coin));

  @override
  _Coin get _value => super._value as _Coin;

  @override
  $Res call({
    Object id = freezed,
    Object symbol = freezed,
    Object name = freezed,
    Object image = freezed,
    Object current_price = freezed,
    Object market_cap = freezed,
    Object market_cap_rank = freezed,
    Object fully_diluted_valuation = freezed,
    Object total_volume = freezed,
    Object high_24h = freezed,
    Object low_24h = freezed,
    Object price_change_24h = freezed,
    Object price_change_percentage_24h = freezed,
    Object market_cap_change_24h = freezed,
    Object market_cap_change_percentage_24h = freezed,
    Object circulating_supply = freezed,
    Object total_supply = freezed,
    Object max_supply = freezed,
    Object ath = freezed,
    Object ath_change_percentage = freezed,
    Object ath_date = freezed,
    Object atl = freezed,
    Object atl_change_percentage = freezed,
    Object atl_date = freezed,
    Object roi = freezed,
    Object last_updated = freezed,
  }) {
    return _then(_Coin(
      id == freezed ? _value.id : id as String,
      symbol == freezed ? _value.symbol : symbol as String,
      name == freezed ? _value.name : name as String,
      image == freezed ? _value.image : image as String,
      current_price == freezed ? _value.current_price : current_price as double,
      market_cap == freezed ? _value.market_cap : market_cap as int,
      market_cap_rank == freezed
          ? _value.market_cap_rank
          : market_cap_rank as int,
      fully_diluted_valuation == freezed
          ? _value.fully_diluted_valuation
          : fully_diluted_valuation as double,
      total_volume == freezed ? _value.total_volume : total_volume as double,
      high_24h == freezed ? _value.high_24h : high_24h as double,
      low_24h == freezed ? _value.low_24h : low_24h as double,
      price_change_24h == freezed
          ? _value.price_change_24h
          : price_change_24h as double,
      price_change_percentage_24h == freezed
          ? _value.price_change_percentage_24h
          : price_change_percentage_24h as double,
      market_cap_change_24h == freezed
          ? _value.market_cap_change_24h
          : market_cap_change_24h as double,
      market_cap_change_percentage_24h == freezed
          ? _value.market_cap_change_percentage_24h
          : market_cap_change_percentage_24h as double,
      circulating_supply == freezed
          ? _value.circulating_supply
          : circulating_supply as double,
      total_supply == freezed ? _value.total_supply : total_supply as double,
      max_supply == freezed ? _value.max_supply : max_supply as double,
      ath == freezed ? _value.ath : ath as double,
      ath_change_percentage == freezed
          ? _value.ath_change_percentage
          : ath_change_percentage as double,
      ath_date == freezed ? _value.ath_date : ath_date as String,
      atl == freezed ? _value.atl : atl as double,
      atl_change_percentage == freezed
          ? _value.atl_change_percentage
          : atl_change_percentage as double,
      atl_date == freezed ? _value.atl_date : atl_date as String,
      roi == freezed ? _value.roi : roi as Map<String, dynamic>,
      last_updated == freezed ? _value.last_updated : last_updated as String,
    ));
  }
}

@JsonSerializable()
class _$_Coin with DiagnosticableTreeMixin implements _Coin {
  const _$_Coin(
      this.id,
      this.symbol,
      this.name,
      this.image,
      this.current_price,
      this.market_cap,
      this.market_cap_rank,
      @nullable this.fully_diluted_valuation,
      this.total_volume,
      @nullable this.high_24h,
      @nullable this.low_24h,
      @nullable this.price_change_24h,
      @nullable this.price_change_percentage_24h,
      @nullable this.market_cap_change_24h,
      @nullable this.market_cap_change_percentage_24h,
      @nullable this.circulating_supply,
      @nullable this.total_supply,
      @nullable this.max_supply,
      @nullable this.ath,
      @nullable this.ath_change_percentage,
      @nullable this.ath_date,
      @nullable this.atl,
      @nullable this.atl_change_percentage,
      @nullable this.atl_date,
      @nullable this.roi,
      this.last_updated)
      : assert(id != null),
        assert(symbol != null),
        assert(name != null),
        assert(image != null),
        assert(current_price != null),
        assert(market_cap != null),
        assert(market_cap_rank != null),
        assert(total_volume != null),
        assert(last_updated != null);

  factory _$_Coin.fromJson(Map<String, dynamic> json) =>
      _$_$_CoinFromJson(json);

  @override
  final String id;
  @override
  final String symbol;
  @override
  final String name;
  @override
  final String image;
  @override
  final double current_price;
  @override
  final int market_cap;
  @override
  final int market_cap_rank;
  @override
  @nullable
  final double fully_diluted_valuation;
  @override
  final double total_volume;
  @override
  @nullable
  final double high_24h;
  @override
  @nullable
  final double low_24h;
  @override
  @nullable
  final double price_change_24h;
  @override
  @nullable
  final double price_change_percentage_24h;
  @override
  @nullable
  final double market_cap_change_24h;
  @override
  @nullable
  final double market_cap_change_percentage_24h;
  @override
  @nullable
  final double circulating_supply;
  @override
  @nullable
  final double total_supply;
  @override
  @nullable
  final double max_supply;
  @override
  @nullable
  final double ath;
  @override
  @nullable
  final double ath_change_percentage;
  @override
  @nullable
  final String ath_date;
  @override
  @nullable
  final double atl;
  @override
  @nullable
  final double atl_change_percentage;
  @override
  @nullable
  final String atl_date;
  @override
  @nullable
  final Map<String, dynamic> roi;
  @override
  final String last_updated;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Coin(id: $id, symbol: $symbol, name: $name, image: $image, current_price: $current_price, market_cap: $market_cap, market_cap_rank: $market_cap_rank, fully_diluted_valuation: $fully_diluted_valuation, total_volume: $total_volume, high_24h: $high_24h, low_24h: $low_24h, price_change_24h: $price_change_24h, price_change_percentage_24h: $price_change_percentage_24h, market_cap_change_24h: $market_cap_change_24h, market_cap_change_percentage_24h: $market_cap_change_percentage_24h, circulating_supply: $circulating_supply, total_supply: $total_supply, max_supply: $max_supply, ath: $ath, ath_change_percentage: $ath_change_percentage, ath_date: $ath_date, atl: $atl, atl_change_percentage: $atl_change_percentage, atl_date: $atl_date, roi: $roi, last_updated: $last_updated)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Coin'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('symbol', symbol))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('image', image))
      ..add(DiagnosticsProperty('current_price', current_price))
      ..add(DiagnosticsProperty('market_cap', market_cap))
      ..add(DiagnosticsProperty('market_cap_rank', market_cap_rank))
      ..add(DiagnosticsProperty(
          'fully_diluted_valuation', fully_diluted_valuation))
      ..add(DiagnosticsProperty('total_volume', total_volume))
      ..add(DiagnosticsProperty('high_24h', high_24h))
      ..add(DiagnosticsProperty('low_24h', low_24h))
      ..add(DiagnosticsProperty('price_change_24h', price_change_24h))
      ..add(DiagnosticsProperty(
          'price_change_percentage_24h', price_change_percentage_24h))
      ..add(DiagnosticsProperty('market_cap_change_24h', market_cap_change_24h))
      ..add(DiagnosticsProperty(
          'market_cap_change_percentage_24h', market_cap_change_percentage_24h))
      ..add(DiagnosticsProperty('circulating_supply', circulating_supply))
      ..add(DiagnosticsProperty('total_supply', total_supply))
      ..add(DiagnosticsProperty('max_supply', max_supply))
      ..add(DiagnosticsProperty('ath', ath))
      ..add(DiagnosticsProperty('ath_change_percentage', ath_change_percentage))
      ..add(DiagnosticsProperty('ath_date', ath_date))
      ..add(DiagnosticsProperty('atl', atl))
      ..add(DiagnosticsProperty('atl_change_percentage', atl_change_percentage))
      ..add(DiagnosticsProperty('atl_date', atl_date))
      ..add(DiagnosticsProperty('roi', roi))
      ..add(DiagnosticsProperty('last_updated', last_updated));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Coin &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.symbol, symbol) ||
                const DeepCollectionEquality().equals(other.symbol, symbol)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.current_price, current_price) ||
                const DeepCollectionEquality()
                    .equals(other.current_price, current_price)) &&
            (identical(other.market_cap, market_cap) ||
                const DeepCollectionEquality()
                    .equals(other.market_cap, market_cap)) &&
            (identical(other.market_cap_rank, market_cap_rank) ||
                const DeepCollectionEquality()
                    .equals(other.market_cap_rank, market_cap_rank)) &&
            (identical(other.fully_diluted_valuation, fully_diluted_valuation) ||
                const DeepCollectionEquality().equals(
                    other.fully_diluted_valuation, fully_diluted_valuation)) &&
            (identical(other.total_volume, total_volume) ||
                const DeepCollectionEquality()
                    .equals(other.total_volume, total_volume)) &&
            (identical(other.high_24h, high_24h) ||
                const DeepCollectionEquality()
                    .equals(other.high_24h, high_24h)) &&
            (identical(other.low_24h, low_24h) ||
                const DeepCollectionEquality()
                    .equals(other.low_24h, low_24h)) &&
            (identical(other.price_change_24h, price_change_24h) ||
                const DeepCollectionEquality()
                    .equals(other.price_change_24h, price_change_24h)) &&
            (identical(other.price_change_percentage_24h, price_change_percentage_24h) ||
                const DeepCollectionEquality().equals(
                    other.price_change_percentage_24h,
                    price_change_percentage_24h)) &&
            (identical(other.market_cap_change_24h, market_cap_change_24h) ||
                const DeepCollectionEquality().equals(
                    other.market_cap_change_24h, market_cap_change_24h)) &&
            (identical(other.market_cap_change_percentage_24h, market_cap_change_percentage_24h) ||
                const DeepCollectionEquality().equals(
                    other.market_cap_change_percentage_24h,
                    market_cap_change_percentage_24h)) &&
            (identical(other.circulating_supply, circulating_supply) ||
                const DeepCollectionEquality()
                    .equals(other.circulating_supply, circulating_supply)) &&
            (identical(other.total_supply, total_supply) ||
                const DeepCollectionEquality()
                    .equals(other.total_supply, total_supply)) &&
            (identical(other.max_supply, max_supply) || const DeepCollectionEquality().equals(other.max_supply, max_supply)) &&
            (identical(other.ath, ath) || const DeepCollectionEquality().equals(other.ath, ath)) &&
            (identical(other.ath_change_percentage, ath_change_percentage) || const DeepCollectionEquality().equals(other.ath_change_percentage, ath_change_percentage)) &&
            (identical(other.ath_date, ath_date) || const DeepCollectionEquality().equals(other.ath_date, ath_date)) &&
            (identical(other.atl, atl) || const DeepCollectionEquality().equals(other.atl, atl)) &&
            (identical(other.atl_change_percentage, atl_change_percentage) || const DeepCollectionEquality().equals(other.atl_change_percentage, atl_change_percentage)) &&
            (identical(other.atl_date, atl_date) || const DeepCollectionEquality().equals(other.atl_date, atl_date)) &&
            (identical(other.roi, roi) || const DeepCollectionEquality().equals(other.roi, roi)) &&
            (identical(other.last_updated, last_updated) || const DeepCollectionEquality().equals(other.last_updated, last_updated)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(symbol) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(current_price) ^
      const DeepCollectionEquality().hash(market_cap) ^
      const DeepCollectionEquality().hash(market_cap_rank) ^
      const DeepCollectionEquality().hash(fully_diluted_valuation) ^
      const DeepCollectionEquality().hash(total_volume) ^
      const DeepCollectionEquality().hash(high_24h) ^
      const DeepCollectionEquality().hash(low_24h) ^
      const DeepCollectionEquality().hash(price_change_24h) ^
      const DeepCollectionEquality().hash(price_change_percentage_24h) ^
      const DeepCollectionEquality().hash(market_cap_change_24h) ^
      const DeepCollectionEquality().hash(market_cap_change_percentage_24h) ^
      const DeepCollectionEquality().hash(circulating_supply) ^
      const DeepCollectionEquality().hash(total_supply) ^
      const DeepCollectionEquality().hash(max_supply) ^
      const DeepCollectionEquality().hash(ath) ^
      const DeepCollectionEquality().hash(ath_change_percentage) ^
      const DeepCollectionEquality().hash(ath_date) ^
      const DeepCollectionEquality().hash(atl) ^
      const DeepCollectionEquality().hash(atl_change_percentage) ^
      const DeepCollectionEquality().hash(atl_date) ^
      const DeepCollectionEquality().hash(roi) ^
      const DeepCollectionEquality().hash(last_updated);

  @override
  _$CoinCopyWith<_Coin> get copyWith =>
      __$CoinCopyWithImpl<_Coin>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_CoinToJson(this);
  }
}

abstract class _Coin implements Coin {
  const factory _Coin(
      String id,
      String symbol,
      String name,
      String image,
      double current_price,
      int market_cap,
      int market_cap_rank,
      @nullable double fully_diluted_valuation,
      double total_volume,
      @nullable double high_24h,
      @nullable double low_24h,
      @nullable double price_change_24h,
      @nullable double price_change_percentage_24h,
      @nullable double market_cap_change_24h,
      @nullable double market_cap_change_percentage_24h,
      @nullable double circulating_supply,
      @nullable double total_supply,
      @nullable double max_supply,
      @nullable double ath,
      @nullable double ath_change_percentage,
      @nullable String ath_date,
      @nullable double atl,
      @nullable double atl_change_percentage,
      @nullable String atl_date,
      @nullable Map<String, dynamic> roi,
      String last_updated) = _$_Coin;

  factory _Coin.fromJson(Map<String, dynamic> json) = _$_Coin.fromJson;

  @override
  String get id;
  @override
  String get symbol;
  @override
  String get name;
  @override
  String get image;
  @override
  double get current_price;
  @override
  int get market_cap;
  @override
  int get market_cap_rank;
  @override
  @nullable
  double get fully_diluted_valuation;
  @override
  double get total_volume;
  @override
  @nullable
  double get high_24h;
  @override
  @nullable
  double get low_24h;
  @override
  @nullable
  double get price_change_24h;
  @override
  @nullable
  double get price_change_percentage_24h;
  @override
  @nullable
  double get market_cap_change_24h;
  @override
  @nullable
  double get market_cap_change_percentage_24h;
  @override
  @nullable
  double get circulating_supply;
  @override
  @nullable
  double get total_supply;
  @override
  @nullable
  double get max_supply;
  @override
  @nullable
  double get ath;
  @override
  @nullable
  double get ath_change_percentage;
  @override
  @nullable
  String get ath_date;
  @override
  @nullable
  double get atl;
  @override
  @nullable
  double get atl_change_percentage;
  @override
  @nullable
  String get atl_date;
  @override
  @nullable
  Map<String, dynamic> get roi;
  @override
  String get last_updated;
  @override
  _$CoinCopyWith<_Coin> get copyWith;
}

PortfolioItem _$PortfolioItemFromJson(Map<String, dynamic> json) {
  return _PortfolioItem.fromJson(json);
}

class _$PortfolioItemTearOff {
  const _$PortfolioItemTearOff();

// ignore: unused_element
  _PortfolioItem call(
      {String coindId,
      String portfolioId,
      double coinAmount,
      double price,
      DateTime purchaseDate}) {
    return _PortfolioItem(
      coindId: coindId,
      portfolioId: portfolioId,
      coinAmount: coinAmount,
      price: price,
      purchaseDate: purchaseDate,
    );
  }
}

// ignore: unused_element
const $PortfolioItem = _$PortfolioItemTearOff();

mixin _$PortfolioItem {
  String get coindId;
  String get portfolioId;
  double get coinAmount;
  double get price;
  DateTime get purchaseDate;

  Map<String, dynamic> toJson();
  $PortfolioItemCopyWith<PortfolioItem> get copyWith;
}

abstract class $PortfolioItemCopyWith<$Res> {
  factory $PortfolioItemCopyWith(
          PortfolioItem value, $Res Function(PortfolioItem) then) =
      _$PortfolioItemCopyWithImpl<$Res>;
  $Res call(
      {String coindId,
      String portfolioId,
      double coinAmount,
      double price,
      DateTime purchaseDate});
}

class _$PortfolioItemCopyWithImpl<$Res>
    implements $PortfolioItemCopyWith<$Res> {
  _$PortfolioItemCopyWithImpl(this._value, this._then);

  final PortfolioItem _value;
  // ignore: unused_field
  final $Res Function(PortfolioItem) _then;

  @override
  $Res call({
    Object coindId = freezed,
    Object portfolioId = freezed,
    Object coinAmount = freezed,
    Object price = freezed,
    Object purchaseDate = freezed,
  }) {
    return _then(_value.copyWith(
      coindId: coindId == freezed ? _value.coindId : coindId as String,
      portfolioId:
          portfolioId == freezed ? _value.portfolioId : portfolioId as String,
      coinAmount:
          coinAmount == freezed ? _value.coinAmount : coinAmount as double,
      price: price == freezed ? _value.price : price as double,
      purchaseDate: purchaseDate == freezed
          ? _value.purchaseDate
          : purchaseDate as DateTime,
    ));
  }
}

abstract class _$PortfolioItemCopyWith<$Res>
    implements $PortfolioItemCopyWith<$Res> {
  factory _$PortfolioItemCopyWith(
          _PortfolioItem value, $Res Function(_PortfolioItem) then) =
      __$PortfolioItemCopyWithImpl<$Res>;
  @override
  $Res call(
      {String coindId,
      String portfolioId,
      double coinAmount,
      double price,
      DateTime purchaseDate});
}

class __$PortfolioItemCopyWithImpl<$Res>
    extends _$PortfolioItemCopyWithImpl<$Res>
    implements _$PortfolioItemCopyWith<$Res> {
  __$PortfolioItemCopyWithImpl(
      _PortfolioItem _value, $Res Function(_PortfolioItem) _then)
      : super(_value, (v) => _then(v as _PortfolioItem));

  @override
  _PortfolioItem get _value => super._value as _PortfolioItem;

  @override
  $Res call({
    Object coindId = freezed,
    Object portfolioId = freezed,
    Object coinAmount = freezed,
    Object price = freezed,
    Object purchaseDate = freezed,
  }) {
    return _then(_PortfolioItem(
      coindId: coindId == freezed ? _value.coindId : coindId as String,
      portfolioId:
          portfolioId == freezed ? _value.portfolioId : portfolioId as String,
      coinAmount:
          coinAmount == freezed ? _value.coinAmount : coinAmount as double,
      price: price == freezed ? _value.price : price as double,
      purchaseDate: purchaseDate == freezed
          ? _value.purchaseDate
          : purchaseDate as DateTime,
    ));
  }
}

@JsonSerializable()
class _$_PortfolioItem with DiagnosticableTreeMixin implements _PortfolioItem {
  const _$_PortfolioItem(
      {this.coindId,
      this.portfolioId,
      this.coinAmount,
      this.price,
      this.purchaseDate});

  factory _$_PortfolioItem.fromJson(Map<String, dynamic> json) =>
      _$_$_PortfolioItemFromJson(json);

  @override
  final String coindId;
  @override
  final String portfolioId;
  @override
  final double coinAmount;
  @override
  final double price;
  @override
  final DateTime purchaseDate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PortfolioItem(coindId: $coindId, portfolioId: $portfolioId, coinAmount: $coinAmount, price: $price, purchaseDate: $purchaseDate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PortfolioItem'))
      ..add(DiagnosticsProperty('coindId', coindId))
      ..add(DiagnosticsProperty('portfolioId', portfolioId))
      ..add(DiagnosticsProperty('coinAmount', coinAmount))
      ..add(DiagnosticsProperty('price', price))
      ..add(DiagnosticsProperty('purchaseDate', purchaseDate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PortfolioItem &&
            (identical(other.coindId, coindId) ||
                const DeepCollectionEquality()
                    .equals(other.coindId, coindId)) &&
            (identical(other.portfolioId, portfolioId) ||
                const DeepCollectionEquality()
                    .equals(other.portfolioId, portfolioId)) &&
            (identical(other.coinAmount, coinAmount) ||
                const DeepCollectionEquality()
                    .equals(other.coinAmount, coinAmount)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.purchaseDate, purchaseDate) ||
                const DeepCollectionEquality()
                    .equals(other.purchaseDate, purchaseDate)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(coindId) ^
      const DeepCollectionEquality().hash(portfolioId) ^
      const DeepCollectionEquality().hash(coinAmount) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(purchaseDate);

  @override
  _$PortfolioItemCopyWith<_PortfolioItem> get copyWith =>
      __$PortfolioItemCopyWithImpl<_PortfolioItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PortfolioItemToJson(this);
  }
}

abstract class _PortfolioItem implements PortfolioItem {
  const factory _PortfolioItem(
      {String coindId,
      String portfolioId,
      double coinAmount,
      double price,
      DateTime purchaseDate}) = _$_PortfolioItem;

  factory _PortfolioItem.fromJson(Map<String, dynamic> json) =
      _$_PortfolioItem.fromJson;

  @override
  String get coindId;
  @override
  String get portfolioId;
  @override
  double get coinAmount;
  @override
  double get price;
  @override
  DateTime get purchaseDate;
  @override
  _$PortfolioItemCopyWith<_PortfolioItem> get copyWith;
}

User _$UserFromJson(Map<String, dynamic> json) {
  return _User.fromJson(json);
}

class _$UserTearOff {
  const _$UserTearOff();

// ignore: unused_element
  _User call(String id, String name, List<String> favourites,
      List<PortfolioItem> portfolioItem) {
    return _User(
      id,
      name,
      favourites,
      portfolioItem,
    );
  }
}

// ignore: unused_element
const $User = _$UserTearOff();

mixin _$User {
  String get id;
  String get name;
  List<String> get favourites;
  List<PortfolioItem> get portfolioItem;

  Map<String, dynamic> toJson();
  $UserCopyWith<User> get copyWith;
}

abstract class $UserCopyWith<$Res> {
  factory $UserCopyWith(User value, $Res Function(User) then) =
      _$UserCopyWithImpl<$Res>;
  $Res call(
      {String id,
      String name,
      List<String> favourites,
      List<PortfolioItem> portfolioItem});
}

class _$UserCopyWithImpl<$Res> implements $UserCopyWith<$Res> {
  _$UserCopyWithImpl(this._value, this._then);

  final User _value;
  // ignore: unused_field
  final $Res Function(User) _then;

  @override
  $Res call({
    Object id = freezed,
    Object name = freezed,
    Object favourites = freezed,
    Object portfolioItem = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      name: name == freezed ? _value.name : name as String,
      favourites: favourites == freezed
          ? _value.favourites
          : favourites as List<String>,
      portfolioItem: portfolioItem == freezed
          ? _value.portfolioItem
          : portfolioItem as List<PortfolioItem>,
    ));
  }
}

abstract class _$UserCopyWith<$Res> implements $UserCopyWith<$Res> {
  factory _$UserCopyWith(_User value, $Res Function(_User) then) =
      __$UserCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      String name,
      List<String> favourites,
      List<PortfolioItem> portfolioItem});
}

class __$UserCopyWithImpl<$Res> extends _$UserCopyWithImpl<$Res>
    implements _$UserCopyWith<$Res> {
  __$UserCopyWithImpl(_User _value, $Res Function(_User) _then)
      : super(_value, (v) => _then(v as _User));

  @override
  _User get _value => super._value as _User;

  @override
  $Res call({
    Object id = freezed,
    Object name = freezed,
    Object favourites = freezed,
    Object portfolioItem = freezed,
  }) {
    return _then(_User(
      id == freezed ? _value.id : id as String,
      name == freezed ? _value.name : name as String,
      favourites == freezed ? _value.favourites : favourites as List<String>,
      portfolioItem == freezed
          ? _value.portfolioItem
          : portfolioItem as List<PortfolioItem>,
    ));
  }
}

@JsonSerializable()
class _$_User with DiagnosticableTreeMixin implements _User {
  const _$_User(this.id, this.name, this.favourites, this.portfolioItem)
      : assert(id != null),
        assert(name != null),
        assert(favourites != null),
        assert(portfolioItem != null);

  factory _$_User.fromJson(Map<String, dynamic> json) =>
      _$_$_UserFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final List<String> favourites;
  @override
  final List<PortfolioItem> portfolioItem;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'User(id: $id, name: $name, favourites: $favourites, portfolioItem: $portfolioItem)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'User'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('favourites', favourites))
      ..add(DiagnosticsProperty('portfolioItem', portfolioItem));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _User &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.favourites, favourites) ||
                const DeepCollectionEquality()
                    .equals(other.favourites, favourites)) &&
            (identical(other.portfolioItem, portfolioItem) ||
                const DeepCollectionEquality()
                    .equals(other.portfolioItem, portfolioItem)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(favourites) ^
      const DeepCollectionEquality().hash(portfolioItem);

  @override
  _$UserCopyWith<_User> get copyWith =>
      __$UserCopyWithImpl<_User>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_UserToJson(this);
  }
}

abstract class _User implements User {
  const factory _User(String id, String name, List<String> favourites,
      List<PortfolioItem> portfolioItem) = _$_User;

  factory _User.fromJson(Map<String, dynamic> json) = _$_User.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  List<String> get favourites;
  @override
  List<PortfolioItem> get portfolioItem;
  @override
  _$UserCopyWith<_User> get copyWith;
}

Favourites _$FavouritesFromJson(Map<String, dynamic> json) {
  return _Favourites.fromJson(json);
}

class _$FavouritesTearOff {
  const _$FavouritesTearOff();

// ignore: unused_element
  _Favourites call(List<String> favouriteList) {
    return _Favourites(
      favouriteList,
    );
  }
}

// ignore: unused_element
const $Favourites = _$FavouritesTearOff();

mixin _$Favourites {
  List<String> get favouriteList;

  Map<String, dynamic> toJson();
  $FavouritesCopyWith<Favourites> get copyWith;
}

abstract class $FavouritesCopyWith<$Res> {
  factory $FavouritesCopyWith(
          Favourites value, $Res Function(Favourites) then) =
      _$FavouritesCopyWithImpl<$Res>;
  $Res call({List<String> favouriteList});
}

class _$FavouritesCopyWithImpl<$Res> implements $FavouritesCopyWith<$Res> {
  _$FavouritesCopyWithImpl(this._value, this._then);

  final Favourites _value;
  // ignore: unused_field
  final $Res Function(Favourites) _then;

  @override
  $Res call({
    Object favouriteList = freezed,
  }) {
    return _then(_value.copyWith(
      favouriteList: favouriteList == freezed
          ? _value.favouriteList
          : favouriteList as List<String>,
    ));
  }
}

abstract class _$FavouritesCopyWith<$Res> implements $FavouritesCopyWith<$Res> {
  factory _$FavouritesCopyWith(
          _Favourites value, $Res Function(_Favourites) then) =
      __$FavouritesCopyWithImpl<$Res>;
  @override
  $Res call({List<String> favouriteList});
}

class __$FavouritesCopyWithImpl<$Res> extends _$FavouritesCopyWithImpl<$Res>
    implements _$FavouritesCopyWith<$Res> {
  __$FavouritesCopyWithImpl(
      _Favourites _value, $Res Function(_Favourites) _then)
      : super(_value, (v) => _then(v as _Favourites));

  @override
  _Favourites get _value => super._value as _Favourites;

  @override
  $Res call({
    Object favouriteList = freezed,
  }) {
    return _then(_Favourites(
      favouriteList == freezed
          ? _value.favouriteList
          : favouriteList as List<String>,
    ));
  }
}

@JsonSerializable()
class _$_Favourites with DiagnosticableTreeMixin implements _Favourites {
  const _$_Favourites(this.favouriteList) : assert(favouriteList != null);

  factory _$_Favourites.fromJson(Map<String, dynamic> json) =>
      _$_$_FavouritesFromJson(json);

  @override
  final List<String> favouriteList;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Favourites(favouriteList: $favouriteList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Favourites'))
      ..add(DiagnosticsProperty('favouriteList', favouriteList));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Favourites &&
            (identical(other.favouriteList, favouriteList) ||
                const DeepCollectionEquality()
                    .equals(other.favouriteList, favouriteList)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(favouriteList);

  @override
  _$FavouritesCopyWith<_Favourites> get copyWith =>
      __$FavouritesCopyWithImpl<_Favourites>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_FavouritesToJson(this);
  }
}

abstract class _Favourites implements Favourites {
  const factory _Favourites(List<String> favouriteList) = _$_Favourites;

  factory _Favourites.fromJson(Map<String, dynamic> json) =
      _$_Favourites.fromJson;

  @override
  List<String> get favouriteList;
  @override
  _$FavouritesCopyWith<_Favourites> get copyWith;
}
